<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides the `#[kernel]` attribute macro. When applied to a function, it compiles it as a CUDA kernel that can be safely called from Rust code on the host."><title>kernel in rust_cuda_kernel - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rust_cuda_kernel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (506985649 2024-07-20)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rust_cuda_kernel/index.html">rust_cuda_kernel</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">rust_cuda_kernel</a>::<wbr><a class="attr" href="#">kernel</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/rust_cuda_kernel/lib.rs.html#54">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[kernel]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides the <a href="attr.kernel.html" title="attr rust_cuda_kernel::kernel"><code>#[kernel]</code></a> attribute macro. When applied to a
function, it compiles it as a CUDA kernel that can be <em>safely</em> called from
Rust code on the host.</p>
<p>The annotated function must be public, not const, not async, not have an
explicit ABI, not be variadic, not have a receiver (e.g. <code>&amp;self</code>), and
return the unit type <code>()</code>. At the moment, the kernel function must also
not use a where clause – use type generic bounds instead.</p>
<p>While the <a href="attr.kernel.html" title="attr rust_cuda_kernel::kernel"><code>#[kernel]</code></a> attribute supports functions with any
number of arguments, <a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/struct.TypedPtxKernel.html"><code>rust_cuda::kernel::TypedPtxKernel</code></a> only supports
launching kernels with up to 12 parameters at the moment.</p>
<p>The <a href="attr.kernel.html" title="attr rust_cuda_kernel::kernel"><code>#[kernel]</code></a> attribute uses the following syntax:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[kernel(<span class="kw">pub</span><span class="question-mark">? </span><span class="kw">use </span><span class="macro">link!</span> <span class="kw">for impl</span>)]
</span><span class="kw">fn </span>my_kernel(<span class="comment">/* parameters */</span>) {
    <span class="comment">/* kernel code */
</span>}</code></pre></div>
<p>where <code>link</code> is the name of a macro that will be generated to manually link
specific monomorphised instantiations of the (optionally generic) kernel
function, and the optional <code>pub</code> controls whether this macro is public or
private.</p>
<p>Note that all kernel parameters must implement the sealed
<a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/trait.CudaKernelParameter.html"><code>rust_cuda::kernel::CudaKernelParameter</code></a> trait.</p>
<p>To use a specific monomorphised instantiation of the kernel, the generated
<code>link!</code> macro must be invoked with the following syntax:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>KernelPtx;
<span class="macro">link!</span> { <span class="kw">impl </span>my_kernel <span class="kw">for </span>KernelPtx }</code></pre></div>
<p>for the non-generic kernel function <code>my_kernel</code> and a non-generic marker
type <code>KernelPtx</code>, which can be used as the generic <code>Kernel</code> type parameter
for <a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/struct.TypedPtxKernel.html"><code>rust_cuda::kernel::TypedPtxKernel</code></a> to instantiate and launch the
kernel. Specifically, the <a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/trait.CompiledKernelPtx.html"><code>rust_cuda::kernel::CompiledKernelPtx</code></a> trait is
implemented for the <code>KernelPtx</code> type.</p>
<p>If the kernel function is generic, the following syntax is used instead:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[kernel(<span class="kw">pub</span><span class="question-mark">? </span><span class="kw">use </span><span class="macro">link!</span> <span class="kw">for impl</span>)]
</span><span class="kw">fn </span>my_kernel&lt;<span class="lifetime">'a</span>, A, B: Bounded, <span class="kw">const </span>N: usize&gt;(<span class="comment">/* parameters */</span>) {
    <span class="comment">/* kernel code */
</span>}

<span class="kw">struct </span>KernelPtx&lt;<span class="lifetime">'a</span>, A, B: Bounded, <span class="kw">const </span>N: usize&gt;(<span class="comment">/* ... */</span>);
<span class="macro">link!</span> { <span class="kw">impl </span>my_kernel&lt;<span class="lifetime">'a</span>, u32, MyStruct, <span class="number">42</span>&gt; <span class="kw">for </span>KernelPtx }
<span class="macro">link!</span> { <span class="kw">impl </span>my_kernel&lt;<span class="lifetime">'a</span>, bool, MyOtherStruct, <span class="number">24</span>&gt; <span class="kw">for </span>KernelPtx }</code></pre></div>
<p>If the kernel generic space is closed, the <code>link!</code> macro can be made
private and all instantiations must be requested in the same crate that
defines the kernel function. If downstream code should be allowed to use
and compile new specific monomorphised instantiations of the kernel, the
<code>link!</code> macro should be publicly exported. Then, downstream code can define
its own <code>MyKernelPtx</code> marker types for which the kernel is linked and which
can be passed to <a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/trait.CompiledKernelPtx.html"><code>rust_cuda::kernel::CompiledKernelPtx</code></a>-generic code in
the kernel-defining crate to construct the requested
<a href="https://juntyr.github.io/rust-cuda/rust_cuda/kernel/struct.TypedPtxKernel.html"><code>rust_cuda::kernel::TypedPtxKernel</code></a>.</p>
<p>Inside the scope of the <a href="attr.kernel.html" title="attr rust_cuda_kernel::kernel"><code>#[kernel]</code></a> attribute, a helper
<code>#[kernel(...)]</code> attribute can be applied to the kernel function:</p>
<ul>
<li><code>#[kernel(crate = "&lt;crate-path&gt;")]</code> changes the path to the <a href="https://juntyr.github.io/rust-cuda/rust_cuda"><code>rust-cuda</code></a>
crate that the kernel compilation uses, which by default is <code>rust_cuda</code>.</li>
<li><code>#[kernel(allow/warn/deny/forbid(&lt;lint&gt;))]</code> checks the specified
CUDA-specific lint for each kernel compilation, using default Rust
semantics for allowing, warning on, denying, or forbidding a lint. The
following lints are supported:
<ul>
<li><code>ptx::double_precision_use</code>: check for any uses of <a href="https://doc.rust-lang.org/nightly/std/primitive.f64.html" title="primitive f64"><code>f64</code></a> operations
inside the compiled PTX binary, as they are often significantly less
performant on NVIDIA GPUs than <a href="https://doc.rust-lang.org/nightly/std/primitive.f32.html" title="primitive f32"><code>f32</code></a> operations. By default,
<code>#[kernel(warn(ptx::double_precision_use))]</code> is set.</li>
<li><code>ptx::local_memory_use</code>: check for any usage of local memory, which may
slow down kernel execution. By default,
<code>#[kernel(warn(ptx::local_memory_use))]</code> is set.</li>
<li><code>ptx::register_spills</code>: check for any spills of registers to local
memory. While using less registers can allow more kernels to be run in
parallel, register spills may also point to missed optimisations. By
default, <code>#[kernel(warn(ptx::register_spills))]</code> is set.</li>
<li><code>ptx::dynamic_stack_size</code>: check if the PTX compiler is unable to
statically determine the size of the required kernel function stack.
When the static stack size is known, the compiler may be able to keep it
entirely within the fast register file. However, when the stack size is
dynamic, more costly memory load and store operations are needed. By
default, <code>#[kernel(warn(ptx::dynamic_stack_size))]</code> is set.</li>
<li><code>ptx::verbose</code>: utility lint to output verbose PTX compiler messages as
warnings (<code>warn</code>) or errors (<code>deny</code> or <code>forbid</code>) or to not output them
(<code>allow</code>). By default, <code>#[kernel(allow(ptx::verbose))]</code> is set.</li>
<li><code>ptx::dump_assembly</code>: utility lint to output the compiled PTX assembly
code as a warning (<code>warn</code>) or an error (<code>deny</code> or <code>forbid</code>) or to not
output it (<code>allow</code>). By default, <code>#[kernel(allow(ptx::dump_assembly))]</code>
is set.</li>
</ul>
</li>
</ul>
</div></details></section></div></main></body></html>